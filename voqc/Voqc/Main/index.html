<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Main (voqc.Voqc.Main)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">voqc</a> &#x00BB; <a href="../index.html">Voqc</a> &#x00BB; Main</nav><header class="odoc-preamble"><h1>Module <code><span>Voqc.Main</span></code></h1><p>Main entry point for VOQC.</p></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#types">Types</a></li><li><a href="#api">API</a><ul><li><a href="#utility-functions">Utility Functions</a></li><li><a href="#optimization-functions">Optimization Functions</a></li><li><a href="#mapping-functions">Mapping Functions</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>VOQC contains utilities for optimizing quantum circuits and mapping them to a connectivity graph. VOQC was first presented at POPL 2021. The extended version of the POPLpaper is available <a href="https://arxiv.org/abs/1912.02250">here</a>. In the remainder of this document we refer to this paper as &quot;POPL VOQC&quot;.</p><p>This file lists the functions we provide in VOQC, as well as properties we have verified about them. In general, our goal is to prove that VOQC circuit transformations are <i>semantics preserving</i>, meaning that the behavior of a circuit (its &quot;semantics&quot;) does not change after our transformations are applied. The semantics of a unitary circuit over d qubits is a 2^d x 2^d unitary matrix, so proving semantics-preservation requires showing that two (symbolic) matrices are equal. Sometimes we also show that the output of a transformation has a particular property, such as using a particular gate set.</p><p>In the remainder of this document, we will use the following shorthand for properties proved:</p><ul><li><p><i>Preserves semantics</i> -- The semantics-preservation property is written in Coq as <code> forall (c : circ), [[opt c]] = [[c]]</code> for optimization <code> opt</code>. In our development, we support several variations on semantics-preservation:</p><ul><li><i>(WT)</i> -- We include the annotation (WT) to indicate that a transformation preserves semantics provided that the input circuit is well-typed. A circuit is &quot;well-typed&quot; for some dimension (i.e. number of qubits) d if every gate in the circuit applies to qubit(s) less than d and no gate has duplicate arguments. Some optimizations do not preserve semantics when the input is ill-typed because they can produce a well-typed circuit from an ill-typed input. In Coq, this requirement is written as <code> forall c, well_typed c -&gt; [[opt c]] = [[c]]</code>.</li><li><i>(phase)</i> -- We include the annotation (phase) to indicate that the semantics are preserved up to a global phase. The unitary matrices X and e^(ix)X have the same action on all input states, and can thus be considered equivalent. However, this definition of equivalence is not compositional in the sense that the controlled versions of these matrices are not equivalent (because the phase is no longer global). In Coq, this restriction is written as <code> forall c, exists x, [[opt c]] = e^(ix) [[c]]</code>.</li><li><i>(perm)</i> -- We include the annotation (perm) to indicate that the semantics are preserved up to a permutation of qubits. This will be the case after applying circuit mapping. In Coq, for permutation matrices P1 and P2, this variation is written as <code> forall c, exists P1 P2, [[c]] = P1 x [[opt c]] x P2</code>.</li></ul></li><li><i>Preserves WT</i> -- This property says that if the input circuit is well-typed, then the output circuit will also be well-typed. In our semantics, the denotation of a well-typed circuit is a unitary matrix while the denotation of an ill-typed circuit is the zero matrix, so all of the variations on semantics-preservation actually imply WT-preservation.</li><li><i>Preserves mapping</i> -- This property says that, for any connectivity graph G, if the input circuit respects the constraints in G then the output circuit also respects the constraints in G. This property allows us to apply optimizations after mapping, preserving our guarantee that the output program satisfies hardware constraints.</li><li><i>Uses gates {g1, ..., gn}</i> -- This property says that every operation in the circuit is an application of one of {g1, ..., gn}.</li><li><i>Respects constraints G</i> -- This property says that every two-qubit interaction in the circuit is allowed by the connectivity graph G.</li></ul><h2 id="types"><a href="#types" class="anchor"></a>Types</h2><div class="odoc-spec"><div class="spec type" id="type-circ" class="anchored"><a href="#type-circ" class="anchor"></a><code><span><span class="keyword">type</span> circ</span><span> =
  <span><a href="../FullGateSet/FullGateSet/index.html#type-coq_Full_Unitary">FullGateSet.FullGateSet.coq_Full_Unitary</a> <a href="../UnitaryListRepresentation/index.html#type-gate_list">UnitaryListRepresentation.gate_list</a></span></span></code></div><div class="spec-doc"><p>The <code>circ</code> type is a list of gates from the full gate set.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-layout" class="anchored"><a href="#type-layout" class="anchor"></a><code><span><span class="keyword">type</span> layout</span></code></div><div class="spec-doc"><p>A <i>layout</i> describes a mapping from logical to physical qubits. For an architecture with n qubits, a layout should be a bijection on integers {0, ..., n-1}. Under the hood, <code>layout</code> is a pair of functions <code>(nat -&gt; nat) * (nat -&gt; nat)</code> that maps logical qubits to physical qubits and physical qubits back to logical qubits. A layout is <i>well-formed</i> if these two functions accurately represent a bijection and its inverse.</p><p>You can construct a layout using the functions <code>list_to_layout</code>, <code>trivial_layout</code>, or <code>greedy_layout</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-c_graph" class="anchored"><a href="#type-c_graph" class="anchor"></a><code><span><span class="keyword">type</span> c_graph</span></code></div><div class="spec-doc"><p>A <i>connectivity graph</i> (<code>c_graph</code>) is a pair <code> nat * (nat -&gt; nat -&gt; bool)</code>, that consists of the total number of qubits in the system and a an oracle that indicates whether a directed edge exists between two qubits.</p><p>You can construct a connectivity graph using <code>make_lnn</code>, <code>make_lnn_ring</code>, or <code>make_grid</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-path_finding_fun" class="anchored"><a href="#type-path_finding_fun" class="anchor"></a><code><span><span class="keyword">type</span> path_finding_fun</span></code></div><div class="spec-doc"><p>A <code>path_finding_fun</code> is a function <code> nat -&gt; nat -&gt; nat list </code> that produces an undirected path between any two nodes in a graph. It is used for circuit mapping.</p><p>You can construct an object of this type using <code>lnn_path_finding_fun</code>, <code>lnn_ring_path_finding_fun</code>, or <code>grid_path_finding_fun</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-qubit_ordering_fun" class="anchored"><a href="#type-qubit_ordering_fun" class="anchor"></a><code><span><span class="keyword">type</span> qubit_ordering_fun</span></code></div><div class="spec-doc"><p>A <code>qubit_ordering_fun</code> is a function <code> nat option -&gt; nat list </code> that produces an ordering of all qubits in the system, excluding its optional argument. It is used for ranking pysical qubits when generating layouts.</p><p>You can construct an object of this type using <code>lnn_qubit_ordering_fun</code> or <code>lnn_ring_qubit_ordering_fun</code>.</p></div></div><h2 id="api"><a href="#api" class="anchor"></a>API</h2><h3 id="utility-functions"><a href="#utility-functions" class="anchor"></a>Utility Functions</h3><div class="odoc-spec"><div class="spec value" id="val-check_well_typed" class="anchored"><a href="#val-check_well_typed" class="anchor"></a><code><span><span class="keyword">val</span> check_well_typed : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if a circuit is well-typed with the given number of qubits (i.e. every gate is applied to qubits within range and never applied to duplicates).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-convert_to_ibm" class="anchored"><a href="#val-convert_to_ibm" class="anchor"></a><code><span><span class="keyword">val</span> convert_to_ibm : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Restrict a program to use gates in the IBM gate set (this may be done implicitly when calling certain optimizations).</p><p><i>Verified Properties</i>: preserves semantics, preserves WT, preserves mapping, uses gates {U1, U2, U3, CX}</p></div></div><div class="odoc-spec"><div class="spec value" id="val-convert_to_rzq" class="anchored"><a href="#val-convert_to_rzq" class="anchor"></a><code><span><span class="keyword">val</span> convert_to_rzq : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Restrict a circuit to use gates in the RzQ gate set (this may be done implicitly when calling certain optimizations).</p><p><i>Verified properties:</i> preserves semantics (phase), preserves WT, preserves mapping, uses gates {H, X, Rzq, CX}</p></div></div><div class="odoc-spec"><div class="spec value" id="val-replace_rzq" class="anchored"><a href="#val-replace_rzq" class="anchor"></a><code><span><span class="keyword">val</span> replace_rzq : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Replace the (non-standard) Rzq gate with its equivalent Rz, Z, T, S, Tdg, or Sdg gate.</p><p><i>Verified Properties:</i> preserves semantics, preserves WT, preserves mapping, uses any gate in the full set except Rzq</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_to_cnot" class="anchored"><a href="#val-decompose_to_cnot" class="anchor"></a><code><span><span class="keyword">val</span> decompose_to_cnot : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Decompose CZ, SWAP, CCX, and CCZ gates so that the only multi-qubit gate is CX (also called &quot;CNOT&quot;).</p><p><i>Verified Properties:</i> preserves semantics, preserves WT, uses any gate in the full set except {CZ, SWAP, CCX, CCZ}</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count_I" class="anchored"><a href="#val-count_I" class="anchor"></a><code><span><span class="keyword">val</span> count_I : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_X" class="anchored"><a href="#val-count_X" class="anchor"></a><code><span><span class="keyword">val</span> count_X : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Y" class="anchored"><a href="#val-count_Y" class="anchor"></a><code><span><span class="keyword">val</span> count_Y : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Z" class="anchored"><a href="#val-count_Z" class="anchor"></a><code><span><span class="keyword">val</span> count_Z : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_H" class="anchored"><a href="#val-count_H" class="anchor"></a><code><span><span class="keyword">val</span> count_H : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_S" class="anchored"><a href="#val-count_S" class="anchor"></a><code><span><span class="keyword">val</span> count_S : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_T" class="anchored"><a href="#val-count_T" class="anchor"></a><code><span><span class="keyword">val</span> count_T : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Sdg" class="anchored"><a href="#val-count_Sdg" class="anchor"></a><code><span><span class="keyword">val</span> count_Sdg : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Tdg" class="anchored"><a href="#val-count_Tdg" class="anchor"></a><code><span><span class="keyword">val</span> count_Tdg : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Rx" class="anchored"><a href="#val-count_Rx" class="anchor"></a><code><span><span class="keyword">val</span> count_Rx : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Ry" class="anchored"><a href="#val-count_Ry" class="anchor"></a><code><span><span class="keyword">val</span> count_Ry : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Rz" class="anchored"><a href="#val-count_Rz" class="anchor"></a><code><span><span class="keyword">val</span> count_Rz : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_Rzq" class="anchored"><a href="#val-count_Rzq" class="anchor"></a><code><span><span class="keyword">val</span> count_Rzq : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_U1" class="anchored"><a href="#val-count_U1" class="anchor"></a><code><span><span class="keyword">val</span> count_U1 : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_U2" class="anchored"><a href="#val-count_U2" class="anchor"></a><code><span><span class="keyword">val</span> count_U2 : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_U3" class="anchored"><a href="#val-count_U3" class="anchor"></a><code><span><span class="keyword">val</span> count_U3 : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_CX" class="anchored"><a href="#val-count_CX" class="anchor"></a><code><span><span class="keyword">val</span> count_CX : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_CZ" class="anchored"><a href="#val-count_CZ" class="anchor"></a><code><span><span class="keyword">val</span> count_CZ : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_SWAP" class="anchored"><a href="#val-count_SWAP" class="anchor"></a><code><span><span class="keyword">val</span> count_SWAP : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_CCX" class="anchored"><a href="#val-count_CCX" class="anchor"></a><code><span><span class="keyword">val</span> count_CCX : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_CCZ" class="anchored"><a href="#val-count_CCZ" class="anchor"></a><code><span><span class="keyword">val</span> count_CCZ : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-count_1q" class="anchored"><a href="#val-count_1q" class="anchor"></a><code><span><span class="keyword">val</span> count_1q : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Count the number of 1-qubit gates.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count_2q" class="anchored"><a href="#val-count_2q" class="anchor"></a><code><span><span class="keyword">val</span> count_2q : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Count the number of 2-qubit gates.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count_3q" class="anchored"><a href="#val-count_3q" class="anchor"></a><code><span><span class="keyword">val</span> count_3q : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Count the number of 3-qubit gates.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count_total" class="anchored"><a href="#val-count_total" class="anchor"></a><code><span><span class="keyword">val</span> count_total : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Count the total number of gates (i.e. length of the instruction list).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count_rzq_clifford" class="anchored"><a href="#val-count_rzq_clifford" class="anchor"></a><code><span><span class="keyword">val</span> count_rzq_clifford : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Count the Rzq gates parameterized by a multiple of PI/2 (i.e. &quot;Clifford&quot; Rz gates).</p></div></div><h3 id="optimization-functions"><a href="#optimization-functions" class="anchor"></a>Optimization Functions</h3><div class="odoc-spec"><div class="spec value" id="val-optimize_ibm" class="anchored"><a href="#val-optimize_ibm" class="anchor"></a><code><span><span class="keyword">val</span> optimize_ibm : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Implementation of Qiskit's <a href="https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.Optimize1qGates.html">Optimize1qGates</a> routine, which merges adjacent 1-qubit gates. Internally uses the IBM gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-not_propagation" class="anchored"><a href="#val-not_propagation" class="anchor"></a><code><span><span class="keyword">val</span> not_propagation : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Implementation of Nam et al.'s &quot;NOT propagation,&quot; which commutes X gates rightward through the circuit, cancelling them when possible (see VOQC POPL Sec 4.3). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hadamard_reduction" class="anchored"><a href="#val-hadamard_reduction" class="anchor"></a><code><span><span class="keyword">val</span> hadamard_reduction : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Implementation of Nam et al.'s &quot;Hadamard gate reduction,&quot; which applies a series of identities to reduce the number of H gates (see VOQC POPL Sec 4.4). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cancel_single_qubit_gates" class="anchored"><a href="#val-cancel_single_qubit_gates" class="anchor"></a><code><span><span class="keyword">val</span> cancel_single_qubit_gates : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Implementation of Nam et al.'s &quot;single-qubit gate cancellation,&quot; which commutes single-qubit gates rightward through the circuit, cancelling them when possible, and reverting them to their original positions if they fail to cancel (see VOQC POPL Sec 4.3). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cancel_two_qubit_gates" class="anchored"><a href="#val-cancel_two_qubit_gates" class="anchor"></a><code><span><span class="keyword">val</span> cancel_two_qubit_gates : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Implementation of Nam et al.'s &quot;two-qubit gate cancellation,&quot; which commutes CX gates rightward through the circuit, cancelling them when possible, and reverting them to their original positions if they fail to cancel (see VOQC POPL Sec 4.3). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge_rotations" class="anchored"><a href="#val-merge_rotations" class="anchor"></a><code><span><span class="keyword">val</span> merge_rotations : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Implementation of Nam et al.'s &quot;rotation merging using phase polynomials,&quot; which combines Rz gates that act on the same logical state (see VOQC POPL Sec 4.4). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-optimize_nam" class="anchored"><a href="#val-optimize_nam" class="anchor"></a><code><span><span class="keyword">val</span> optimize_nam : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Run optimizations in the order 0, 1, 3, 2, 3, 1, 2, 4, 3, 2 where 0 is <code>not_propagation</code>, 1 is <code>hadamard_reduction</code>, 2 is <code>cancel_single_qubit_gates</code>, 3 is <code>cancel_two_qubit_gates</code>, and 4 is <code>merge_rotations</code> (see VOQC POPL Sec 4.6).</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-optimize_nam_light" class="anchored"><a href="#val-optimize_nam_light" class="anchor"></a><code><span><span class="keyword">val</span> optimize_nam_light : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Run optimizations in the order 0, 1, 3, 2, 3, 1, 2, using the same numbering scheme as above. This will be faster than <code>optimize_nam</code> because it excludes rotation merging, which is our slowest optimization.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-optimize_nam_lcr" class="anchored"><a href="#val-optimize_nam_lcr" class="anchor"></a><code><span><span class="keyword">val</span> optimize_nam_lcr : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>(<a href="#type-circ">circ</a> * <a href="#type-circ">circ</a>)</span> * <a href="#type-circ">circ</a>)</span> option</span></span></code></div><div class="spec-doc"><p>Use <code>optimize_nam</code> to optimize across loop iterations. To count the gates required for n iterations, use <code>count_gates_lcr</code>.</p><p><i>Verified Properties:</i> Say that this function returns <code>Some (l, c, r)</code> on input <code>c0</code>. Then for any n &gt;= 3, iterating <code>c0</code> n times is equivalent to running <code>l</code> once, <code>c</code> n-2 times, and <code>r</code> once. If <code>c0</code> is well-typed then <code>l, c, r</code> are also well-typed. If <code>c0</code> is properly mapped then <code>l, c, r</code> are also properly mapped.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-optimize" class="anchored"><a href="#val-optimize" class="anchor"></a><code><span><span class="keyword">val</span> optimize : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p><code>optimize_nam</code> followed by <code>optimize_ibm</code>.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></div></div><h3 id="mapping-functions"><a href="#mapping-functions" class="anchor"></a>Mapping Functions</h3><div class="odoc-spec"><div class="spec value" id="val-swap_route" class="anchored"><a href="#val-swap_route" class="anchor"></a><code><span><span class="keyword">val</span> swap_route : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-layout">layout</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-c_graph">c_graph</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-path_finding_fun">path_finding_fun</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Map a circuit to an architecture given an initial layout.</p><p><i>Verified properties:</i> Provided that that the input circuit is well-typed using the dimension stored in the input graph and the input layout and graph are well-formed, this transformation preserves semantics (WT, perm) and preserves WT. Furthermore, the output <code>c</code> respects the (undirected) constraints of the input graph.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_swaps" class="anchored"><a href="#val-decompose_swaps" class="anchor"></a><code><span><span class="keyword">val</span> decompose_swaps : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-c_graph">c_graph</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Decompose swap gates and reorient cnot gates to satisfy connectivity constraints.</p><p><i>Verified properties:</i> Provided that that the input circuit is well-typed using the dimension stored in the input graph, this transformation preserves semantics and preserves WT. Furthermore, if the input circuit restpects the (undirected) constraints of the graph, then the output respects the (directed) constraints.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-trivial_layout" class="anchored"><a href="#val-trivial_layout" class="anchor"></a><code><span><span class="keyword">val</span> trivial_layout : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-layout">layout</a></span></code></div><div class="spec-doc"><p>Create a trivial layout on n qubits (i.e. logical qubit i is mapped to physical qubit i).</p><p><i>Verified Properties:</i> The output layout is well-formed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_list" class="anchored"><a href="#val-check_list" class="anchor"></a><code><span><span class="keyword">val</span> check_list : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if a list is a permutation over <code>[0...(n-1)]</code>, meaning that it is valid input to <code>list_to_layout</code>.</p><p><i>Verified Properties:</i> If <code>check_list</code> returns true, the layout output by <code>list_to_layout</code> is well-formed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list_to_layout" class="anchored"><a href="#val-list_to_layout" class="anchor"></a><code><span><span class="keyword">val</span> list_to_layout : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-layout">layout</a></span></code></div><div class="spec-doc"><p>Make a layout from a list. Example: the list <code>[3; 4; 1; 2; 0]</code> is transformed to a layout with physical to logical qubit mapping {0-&gt;3, 1-&gt;4, 2-&gt;1, 3-&gt;2, 4-&gt;0} (so physical qubit 0 stores logical qubit 3) and the appropriate inverse logical to physical mapping.</p><p><i>Verified Properties:</i> If <code>check_list</code> returns true, the layout output by <code>list_to_layout</code> is well-formed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-layout_to_list" class="anchored"><a href="#val-layout_to_list" class="anchor"></a><code><span><span class="keyword">val</span> layout_to_list : <span><a href="#type-layout">layout</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p>Convert a layout to a list for easier printing. Example: the layout with physical to logical qubit mapping {0-&gt;3, 1-&gt;4, 2-&gt;1, 3-&gt;2, 4-&gt;0} is transformed to the list <code>[3; 4; 1; 2; 0]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-greedy_layout" class="anchored"><a href="#val-greedy_layout" class="anchor"></a><code><span><span class="keyword">val</span> greedy_layout : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-c_graph">c_graph</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-qubit_ordering_fun">qubit_ordering_fun</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-layout">layout</a></span></code></div><div class="spec-doc"><p>Choose an initial layout for a program that puts qubits close together on the architecture if they are used together in a two-qubit gate.</p><p><i>Verified Properties:</i> The output layout is well-formed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_lnn" class="anchored"><a href="#val-make_lnn" class="anchor"></a><code><span><span class="keyword">val</span> make_lnn : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-c_graph">c_graph</a></span></code></div><div class="spec-doc"><p>Create a 1D LNN graph with n qubits (see POPL VOQC Fig 8(b)).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_lnn_ring" class="anchored"><a href="#val-make_lnn_ring" class="anchor"></a><code><span><span class="keyword">val</span> make_lnn_ring : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-c_graph">c_graph</a></span></code></div><div class="spec-doc"><p>Create a 1D LNN ring graph with n qubits (see POPL VOQC Fig 8(c)).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_grid" class="anchored"><a href="#val-make_grid" class="anchor"></a><code><span><span class="keyword">val</span> make_grid : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-c_graph">c_graph</a></span></code></div><div class="spec-doc"><p>Create a m x n 2D grid (see POPL VOQC Fig 8(d)).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-c_graph_from_coupling_map" class="anchored"><a href="#val-c_graph_from_coupling_map" class="anchor"></a><code><span><span class="keyword">val</span> c_graph_from_coupling_map : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span>(int * int)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-c_graph">c_graph</a></span></code></div><div class="spec-doc"><p>Create a connectivity graph from a list of pairs describing edges in the graph.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lnn_path_finding_fun" class="anchored"><a href="#val-lnn_path_finding_fun" class="anchor"></a><code><span><span class="keyword">val</span> lnn_path_finding_fun : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-path_finding_fun">path_finding_fun</a></span></code></div><div class="spec-doc"><p>Get a function to find paths in a 1D LNN graph.</p><p><i>Verified Properties:</i> The function returns valid paths.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lnn_ring_path_finding_fun" class="anchored"><a href="#val-lnn_ring_path_finding_fun" class="anchor"></a><code><span><span class="keyword">val</span> lnn_ring_path_finding_fun : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-path_finding_fun">path_finding_fun</a></span></code></div><div class="spec-doc"><p>Get a function to find paths in a 1D LNN ring graph.</p><p><i>Verified Properties:</i> The function returns valid paths.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-grid_path_finding_fun" class="anchored"><a href="#val-grid_path_finding_fun" class="anchor"></a><code><span><span class="keyword">val</span> grid_path_finding_fun : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-path_finding_fun">path_finding_fun</a></span></code></div><div class="spec-doc"><p>Get a function to find paths in a 2D grid.</p><p><i>Verified Properties:</i> The function returns valid paths.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lnn_qubit_ordering_fun" class="anchored"><a href="#val-lnn_qubit_ordering_fun" class="anchor"></a><code><span><span class="keyword">val</span> lnn_qubit_ordering_fun : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-qubit_ordering_fun">qubit_ordering_fun</a></span></code></div><div class="spec-doc"><p>Generate a preference-ordering function for qubits in a 1D LNN graph.</p><p><i>Verified Properties:</i> The ordering function is valid.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lnn_ring_qubit_ordering_fun" class="anchored"><a href="#val-lnn_ring_qubit_ordering_fun" class="anchor"></a><code><span><span class="keyword">val</span> lnn_ring_qubit_ordering_fun : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-qubit_ordering_fun">qubit_ordering_fun</a></span></code></div><div class="spec-doc"><p>Generate a preference-ordering function for qubits in a 1D LNN ring graph.</p><p><i>Verified Properties:</i> The ordering function is valid.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_swaps" class="anchored"><a href="#val-remove_swaps" class="anchor"></a><code><span><span class="keyword">val</span> remove_swaps : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-layout">layout</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-circ">circ</a></span></code></div><div class="spec-doc"><p>Remove all swap gates from a program, instead performing a logical relabeling of qubits.</p><p><i>Verified Properties:</i> Provided that that the input circuit is well-typed and the input layout is well-formed, this transformation preserves semantics (WT, perm) and preserves WT.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_swap_equivalence" class="anchored"><a href="#val-check_swap_equivalence" class="anchor"></a><code><span><span class="keyword">val</span> check_swap_equivalence : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-layout">layout</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-layout">layout</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if two programs (and their initial layouts) are equivalent up to inserted swaps gates. This function can be used to validate circuit routing routines.</p><p><i>Verified Properties:</i> Assuming the input circuits are well-typed and the input layouts are well formed, if this function returns true then the programs are equivalent up to a permutation of qubits.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_constraints" class="anchored"><a href="#val-check_constraints" class="anchor"></a><code><span><span class="keyword">val</span> check_constraints : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-c_graph">c_graph</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if a circuit satisfies the constraints of a connectivity graph.</p><p><i>Verified Properties:</i> If this function returns true, the program satisfies the constraints of the connectivity graph.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-optimize_and_map_to_lnn_ring_16" class="anchored"><a href="#val-optimize_and_map_to_lnn_ring_16" class="anchor"></a><code><span><span class="keyword">val</span> optimize_and_map_to_lnn_ring_16 : <span><a href="#type-circ">circ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-circ">circ</a> option</span></span></code></div><div class="spec-doc"><p>Example composition of transformations. Applies <code>optimize_nam</code>, followed by <code>swap_route</code> using the 16-qubit LNN ring architecture, followed by <code>optimize</code>.</p><p><i>Verified Properties:</i> If this function returns <code>Some c</code>, then it preserves semantics (WT, phase) and <code>c</code> respects the (directed) constraints of the LNN ring graph.</p></div></div></div></body></html>