<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Voqc__Main (voqc.Voqc__Main)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">voqc</a> &#x00BB; Voqc__Main</nav><h1>Module <code>Voqc__Main</code></h1><nav class="toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#types">Types</a></li><li><a href="#api">API</a><ul><li><a href="#utility-functions">Utility Functions</a></li><li><a href="#optimization-functions">Optimization Functions</a></li><li><a href="#mapping-functions">Mapping Functions</a></li></ul></li></ul></nav></header><section><header><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2></header><aside><p>VOQC contains utilities for optimizing quantum circuits and mapping them to a connectivity graph. VOQC was first presented at POPL 2021. The extended version of the paper is available <a href="https://arxiv.org/abs/1912.02250">here</a>. In the remainder of this document we will refer to this paper as &quot;POPL VOQC&quot;.</p></aside><aside><p>This file lists the functions we provide in VOQC, as well as properties we have verified about them. In general, our goal is to prove that VOQC circuit transformations are <i>semantics preserving</i>, meaning that the behavior of a circuit (its &quot;semantics&quot;) does not change after our transformations are applied. The semantics of a unitary circuit over d qubits is a 2^d x 2^d unitary matrix, so proving semantics-preservation requires showing that two (symbolic) matrices are equal. Sometimes we also show that the output of a transformation has a particular property, such as using a particular gate set.</p><p>In the remainder of this document, we will use the following shorthand for properties proved:</p><ul><li><p><i>Preserves semantics</i> -- The semantics-preservation property is written in Coq as <code> forall (c : circ), [[opt c]] = [[c]]</code> for optimization <code> opt</code>. In our development, we support several variations on semantics-preservation:</p><ul><li><i>(WT)</i> -- We include the annotation (WT) to indicate that a transformation preserves semantics provided that the input circuit is well-typed. A circuit is &quot;well-typed&quot; for some dimension (i.e. number of qubits) d if every gate in the circuit applies to some qubit less than d and no gate has duplicate arguments. Some optimizations do not preserve semantics when the input is ill-typed because they can produce a well-typed circuit from an ill-typed input. In Coq, this requirement is written as <code> forall c, well_typed c -&gt; [[opt c]] = [[c]]</code>.</li><li><i>(phase)</i> -- We include the annotation (phase) to indicate that the semantics are preserved up to a global phase. The unitary matrices X and e^(ix)X have the same action on all input states, and can thus be considered equivalent. However, this definition of equivalence is not compositional in the sense that the controlled versions of these matrices are not equivalent (because the phase is no longer global). In Coq, this restriction is written as <code> forall c, exists x, [[opt c]] = e^(ix) [[c]]</code>.</li><li><i>(perm)</i> -- We include the annotation (perm) to indicate that the semantics are preserved up to a permutation of qubits. This will be the case after applying circuit mapping. In Coq, for permutation matrices P1 and P2, this variation is written as <code> forall c, [[c]] = P1 x [[opt c]] x P2</code>.</li></ul></li><li><i>Preserves WT</i> -- This property says that if the input circuit is well-typed, then the output circuit will also be well-typed. In our semantics, the denotation of a well-typed circuit is a unitary matrix while the denotation of an ill-typed circuit is the zero matrix, so all of the variations on semantics-preservation actually imply WT-preservation.</li><li><i>Preserves mapping</i> -- This property says that, for any connectivity graph G, if the input circuit respects the constraints in G then the output circuit also respects the constraints in G. This property allows us to apply optimizations after mapping, preserving our guarantee that the output program satisfies hardware constraints.</li><li><i>Uses gates {g1, ..., gn}</i> -- This property says that every operation in the circuit is an application of one of {g1, ..., gn}.</li><li><i>Respects constraints G</i> -- This property says that every two-qubit interaction in the circuit is allowed by the connectivity graph G.</li></ul></aside></section><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-circ"><a href="#type-circ" class="anchor"></a><code><span class="keyword">type</span> circ</code><code> = <span><a href="../Voqc/StandardGateSet/StandardGateSet/index.html#type-coq_Std_Unitary">Voqc.StandardGateSet.StandardGateSet.coq_Std_Unitary</a> <a href="../Voqc/UnitaryListRepresentation/index.html#type-gate_list">Voqc.UnitaryListRepresentation.gate_list</a></span></code></dt><dd><p>The <code>circ</code> type is a list of gates from the standard gate set.</p></dd></dl><dl><dt class="spec type" id="type-gate_counts"><a href="#type-gate_counts" class="anchor"></a><code><span class="keyword">type</span> gate_counts</code><code> = </code><table class="variant"><tr id="type-gate_counts.BuildCounts" class="anchored"><td class="def constructor"><a href="#type-gate_counts.BuildCounts" class="anchor"></a><code>| </code><code><span class="constructor">BuildCounts</span> <span class="keyword">of</span> int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int</code></td></tr></table></dt><dd><p><code>gate_counts</code> is the return type for <code>count_gates</code>. It stores the count of each gate type in the following order: { I, X, Y, Z, H, S, T, Sdg, Tdg, Rx, Ry, Rz, Rz, U1, U2, U3, CX, CZ , SWAP, CCX, CCZ }.</p></dd></dl><dl><dt class="spec type" id="type-layout"><a href="#type-layout" class="anchor"></a><code><span class="keyword">type</span> layout</code></dt><dd><p>A <i>layout</i> describes a mapping from logical to physical qubits. For an architecture with n qubits, a layout should be a bijection on integers {0, ..., n-1}. Under the hood, <code>layout</code> is a pair of functions <code>(nat -&gt; nat) * (nat -&gt; nat)</code> that maps logical qubits to physical qubits and physical qubits back to logical qubits. A layout is <i>well-formed</i> if these two functions accurately represent a bijection and its inverse.</p><p>You can construct a layout using the function <code>list_to_layout</code>.</p></dd></dl><dl><dt class="spec type" id="type-c_graph"><a href="#type-c_graph" class="anchor"></a><code><span class="keyword">type</span> c_graph</code></dt><dd><p>A <i>connectivity graph</i> (<code>c_graph</code>) is a triple <code> nat * (nat -&gt; nat -&gt; list nat) * (nat -&gt; nat -&gt; bool)</code>, which consists of the total number of qubits in the system, a function to generate an undirected path between any two qubits, and an oracle that indicates whether a directed edge exists between two qubits. A connectivity graph is <i>well-formed</i> if the function to get paths returns a valid path between any two qubits in the system.</p><p>You can construct a connectivity graph using <code>make_tenerife</code>, <code>make_lnn</code>, <code>make_lnn_ring</code>, or <code>make_grid</code>.</p></dd></dl></section><section><header><h2 id="api"><a href="#api" class="anchor"></a>API</h2></header><section><header><h3 id="utility-functions"><a href="#utility-functions" class="anchor"></a>Utility Functions</h3></header><dl><dt class="spec value" id="val-check_well_typed"><a href="#val-check_well_typed" class="anchor"></a><code><span class="keyword">val</span> check_well_typed : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if a circuit is well-typed with the given number of qubits (i.e. every gate is applied to qubits within range and never applied to duplicates).</p></dd></dl><dl><dt class="spec value" id="val-convert_to_ibm"><a href="#val-convert_to_ibm" class="anchor"></a><code><span class="keyword">val</span> convert_to_ibm : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Restrict a program to use gates in the IBM gate set (this may be done implicitly when calling certain optimizations).</p><p><i>Verified Properties</i>: preserves semantics, preserves WT, preserves mapping, uses gates {U1, U2, U3, CX}</p></dd></dl><dl><dt class="spec value" id="val-convert_to_rzq"><a href="#val-convert_to_rzq" class="anchor"></a><code><span class="keyword">val</span> convert_to_rzq : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Restrict a circuit to use gates in the RzQ gate set (this may be done implicitly when calling certain optimizations).</p><p><i>Verified properties:</i> preserves semantics (phase), preserves WT, preserves mapping, uses gates {H, X, Rzq, CX}</p></dd></dl><dl><dt class="spec value" id="val-replace_rzq"><a href="#val-replace_rzq" class="anchor"></a><code><span class="keyword">val</span> replace_rzq : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Replace the (non-standard) Rzq gate with its equivalent Rz, Z, T, S, Tdg, or Sdg gate.</p><p><i>Verified Properties:</i> preserves semantics, preserves WT, preserves mapping, uses any gate in the standard set except Rzq</p></dd></dl><dl><dt class="spec value" id="val-decompose_to_cnot"><a href="#val-decompose_to_cnot" class="anchor"></a><code><span class="keyword">val</span> decompose_to_cnot : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Decompose CZ, SWAP, CCX, and CCZ gates so that the only multi-qubit gate is CX (also called &quot;CNOT&quot;).</p><p><i>Verified Properties:</i> preserves semantics, preserves WT, uses any gate in the standard set except {CZ, SWAP, CCX, CCZ}</p></dd></dl><dl><dt class="spec value" id="val-count_gates"><a href="#val-count_gates" class="anchor"></a><code><span class="keyword">val</span> count_gates : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-gate_counts">gate_counts</a></code></dt><dd><p>Count all types of gates in the program. Note that this count is <i>syntactic</i> in the sense that gates like Rz, Rzq, and U1 are counted separately even though they all could be considered a U1 gate. Similarly, the count for X does not include gates of the form U3(PI,0,PI), even though this is functionally the same.</p></dd></dl><dl><dt class="spec value" id="val-total_gate_count"><a href="#val-total_gate_count" class="anchor"></a><code><span class="keyword">val</span> total_gate_count : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Count the total number of gates (i.e. length of the instruction list).</p></dd></dl><dl><dt class="spec value" id="val-count_clifford_rzq"><a href="#val-count_clifford_rzq" class="anchor"></a><code><span class="keyword">val</span> count_clifford_rzq : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Count the Rzq gates parameterized by a multiple of PI/2 (i.e. &quot;Clifford&quot; Rz gates).</p></dd></dl><dl><dt class="spec value" id="val-scale_count"><a href="#val-scale_count" class="anchor"></a><code><span class="keyword">val</span> scale_count : <a href="index.html#type-gate_counts">gate_counts</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-gate_counts">gate_counts</a></code></dt><dd><p>Multiply all gate counts by a factor n.</p></dd></dl><dl><dt class="spec value" id="val-add_counts"><a href="#val-add_counts" class="anchor"></a><code><span class="keyword">val</span> add_counts : <a href="index.html#type-gate_counts">gate_counts</a> <span>&#45;&gt;</span> <a href="index.html#type-gate_counts">gate_counts</a> <span>&#45;&gt;</span> <a href="index.html#type-gate_counts">gate_counts</a></code></dt><dd><p>Add gate counts.</p></dd></dl><dl><dt class="spec value" id="val-count_gates_lcr"><a href="#val-count_gates_lcr" class="anchor"></a><code><span class="keyword">val</span> count_gates_lcr : <span>(<span>(<a href="index.html#type-circ">circ</a> * <a href="index.html#type-circ">circ</a>)</span> * <a href="index.html#type-circ">circ</a>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-gate_counts">gate_counts</a></code></dt><dd><p>Compute the gates required for n iterations of the input LCR decomposition (see <code>optimize_nam_lcr</code>).</p></dd></dl></section><section><header><h3 id="optimization-functions"><a href="#optimization-functions" class="anchor"></a>Optimization Functions</h3></header><dl><dt class="spec value" id="val-optimize_1q_gates"><a href="#val-optimize_1q_gates" class="anchor"></a><code><span class="keyword">val</span> optimize_1q_gates : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Implementation of Qiskit's <a href="https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.Optimize1qGates.html">Optimize1qGates</a> routine, which merges adjacent 1-qubit gates. Internally uses the IBM gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-cx_cancellation"><a href="#val-cx_cancellation" class="anchor"></a><code><span class="keyword">val</span> cx_cancellation : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Implementation of Qiskit's <a href="https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.CXCancellation.html">CXCancellation</a> routine, which cancels adjacent CX gates. Internally uses the IBM gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-optimize_ibm"><a href="#val-optimize_ibm" class="anchor"></a><code><span class="keyword">val</span> optimize_ibm : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Run <code>optimize_1q_gates</code> followed by <code>cx_cancellation</code>.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-not_propagation"><a href="#val-not_propagation" class="anchor"></a><code><span class="keyword">val</span> not_propagation : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Implementation of Nam et al.'s &quot;NOT propagation,&quot; which commutes X gates rightward through the circuit, cancelling them when possible (see VOQC POPL Sec 4.3). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-hadamard_reduction"><a href="#val-hadamard_reduction" class="anchor"></a><code><span class="keyword">val</span> hadamard_reduction : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Implementation of Nam et al.'s &quot;Hadamard gate reduction,&quot; which applies a series of identities to reduce the number of H gates (see VOQC POPL Sec 4.4). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-cancel_single_qubit_gates"><a href="#val-cancel_single_qubit_gates" class="anchor"></a><code><span class="keyword">val</span> cancel_single_qubit_gates : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Implementation of Nam et al.'s &quot;single-qubit gate cancellation,&quot; which commutes single-qubit gates rightward through the circuit, cancelling them when possible, and reverting them to their original positions if they fail to cancel (see VOQC POPL Sec 4.3). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-cancel_two_qubit_gates"><a href="#val-cancel_two_qubit_gates" class="anchor"></a><code><span class="keyword">val</span> cancel_two_qubit_gates : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Implementation of Nam et al.'s &quot;two-qubit gate cancellation,&quot; which commutes CX gates rightward through the circuit, cancelling them when possible, and reverting them to their original positions if they fail to cancel (see VOQC POPL Sec 4.3). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-merge_rotations"><a href="#val-merge_rotations" class="anchor"></a><code><span class="keyword">val</span> merge_rotations : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Implementation of Nam et al.'s &quot;rotation merging using phase polynomials,&quot; which combines Rz gates that act on the same logical state (see VOQC POPL Sec 4.4). Internally uses the RzQ gate set.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-optimize_nam"><a href="#val-optimize_nam" class="anchor"></a><code><span class="keyword">val</span> optimize_nam : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Run optimizations in the order 0, 1, 3, 2, 3, 1, 2, 4, 3, 2 where 0 is <code>not_propagation</code>, 1 <code>hadamard_reduction</code>, 2 is <code>cancel_single_qubit_gates</code>, 3 is <code>cancel_two_qubit_gates</code>, and 4 is <code>merge_rotations</code> (see VOQC POPL Sec 4.6).</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-optimize_nam_light"><a href="#val-optimize_nam_light" class="anchor"></a><code><span class="keyword">val</span> optimize_nam_light : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a></code></dt><dd><p>Run optimizations in the order 0, 1, 3, 2, 3, 1, 2, using the same numbering scheme as above. This will be faster than <code>optimize_nam</code> because it excludes rotation merging, which is our slowest optimization.</p><p><i>Verified Properties:</i> Preserves semantics (WT, phase), preserves WT, preserves mapping</p></dd></dl><dl><dt class="spec value" id="val-optimize_nam_lcr"><a href="#val-optimize_nam_lcr" class="anchor"></a><code><span class="keyword">val</span> optimize_nam_lcr : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <span><span>(<span>(<a href="index.html#type-circ">circ</a> * <a href="index.html#type-circ">circ</a>)</span> * <a href="index.html#type-circ">circ</a>)</span> option</span></code></dt><dd><p>Use <code>optimize_nam</code> to optimize across loop iterations. To count the gates required for n iterations, use <code>count_gates_lcr</code>.</p><p><i>Verified Properties:</i> Say that this function returns <code>Some (l, c, r)</code> on input <code>c0</code>. Then for any n &gt;= 3, iterating <code>c0</code> n times is equivalent to running <code>l</code> once, <code>c</code> n-2 times, and <code>r</code> once. If <code>c0</code> is well-typed then <code>l, c, r</code> are also well-typed. If <code>c0</code> is properly mapped then <code>l, c, r</code> are also properly mapped.</p></dd></dl></section><section><header><h3 id="mapping-functions"><a href="#mapping-functions" class="anchor"></a>Mapping Functions</h3></header><dl><dt class="spec value" id="val-check_layout"><a href="#val-check_layout" class="anchor"></a><code><span class="keyword">val</span> check_layout : <a href="index.html#type-layout">layout</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if a layout is well-formed.</p></dd></dl><dl><dt class="spec value" id="val-check_graph"><a href="#val-check_graph" class="anchor"></a><code><span class="keyword">val</span> check_graph : <a href="index.html#type-c_graph">c_graph</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if a graph is well-formed. This function will make O(n^2) calls to the path finding function for n qubits, so it will likely be slow.</p></dd></dl><dl><dt class="spec value" id="val-check_constraints"><a href="#val-check_constraints" class="anchor"></a><code><span class="keyword">val</span> check_constraints : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-c_graph">c_graph</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if a circuit satisfies the constraints of a connectivity graph.</p></dd></dl><dl><dt class="spec value" id="val-simple_map"><a href="#val-simple_map" class="anchor"></a><code><span class="keyword">val</span> simple_map : <a href="index.html#type-circ">circ</a> <span>&#45;&gt;</span> <a href="index.html#type-layout">layout</a> <span>&#45;&gt;</span> <a href="index.html#type-c_graph">c_graph</a> <span>&#45;&gt;</span> <a href="index.html#type-circ">circ</a> * <a href="index.html#type-layout">layout</a></code></dt><dd><p>Return <code>(c, la)</code> where <code>c</code> is the mapped circuit and <code>la</code> is the final layout.</p><p><i>Verified properties:</i> Provided that that the input circuit is well-typed using the dimension stored in the input graph and the input layout and graph are well-formed, this transformation preserves semantics (WT, perm) and preserves WT. Furthermore, the output <code>c</code> respects the constraints the input graph and <code>la</code> is well-formed.</p></dd></dl><dl><dt class="spec value" id="val-make_tenerife"><a href="#val-make_tenerife" class="anchor"></a><code><span class="keyword">val</span> make_tenerife : unit <span>&#45;&gt;</span> <a href="index.html#type-c_graph">c_graph</a></code></dt><dd><p>Create a graph for <a href="https://github.com/Qiskit/ibmq-device-information/blob/master/backends/tenerife/V1/version_log.md">IBM's 5-qubit Tenerife machine</a>).</p><p><i>Verified Properties:</i> The output connectivity graph is well-formed.</p></dd></dl><dl><dt class="spec value" id="val-make_lnn"><a href="#val-make_lnn" class="anchor"></a><code><span class="keyword">val</span> make_lnn : int <span>&#45;&gt;</span> <a href="index.html#type-c_graph">c_graph</a></code></dt><dd><p>Create a 1D LNN graph with n qubits (see POPL VOQC Fig 8(b)).</p><p><i>Verified Properties:</i> The output connectivity graph is well-formed.</p></dd></dl><dl><dt class="spec value" id="val-make_lnn_ring"><a href="#val-make_lnn_ring" class="anchor"></a><code><span class="keyword">val</span> make_lnn_ring : int <span>&#45;&gt;</span> <a href="index.html#type-c_graph">c_graph</a></code></dt><dd><p>Create a 1D LNN ring graph with n qubits (see POPL VOQC Fig 8(c)).</p><p><i>Verified Properties:</i> The output connectivity graph is well-formed.</p></dd></dl><dl><dt class="spec value" id="val-make_grid"><a href="#val-make_grid" class="anchor"></a><code><span class="keyword">val</span> make_grid : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-c_graph">c_graph</a></code></dt><dd><p>Create a m x n 2D grid (see POPL VOQC Fig 8(d)).</p><p><i>Verified Properties:</i> The output connectivity graph is well-formed.</p></dd></dl><dl><dt class="spec value" id="val-trivial_layout"><a href="#val-trivial_layout" class="anchor"></a><code><span class="keyword">val</span> trivial_layout : int <span>&#45;&gt;</span> <a href="index.html#type-layout">layout</a></code></dt><dd><p>Create a trivial layout on n qubits (i.e. logical qubit i is mapped to physical qubit i).</p><p><i>Verified Properties:</i> The output layout is well-formed.</p></dd></dl><dl><dt class="spec value" id="val-list_to_layout"><a href="#val-list_to_layout" class="anchor"></a><code><span class="keyword">val</span> list_to_layout : <span>int list</span> <span>&#45;&gt;</span> <a href="index.html#type-layout">layout</a></code></dt><dd><p>Make a layout from a list. Example: the list <code>[3; 4; 1; 2; 0]</code> is transformed to a layout with physical to logical qubit mapping {0-&gt;3, 1-&gt;4, 2-&gt;1, 3-&gt;2, 4-&gt;0} (so physical qubit 0 stores logical qubit 3) and the appropriate inverse logical to physical mapping.</p></dd></dl><dl><dt class="spec value" id="val-layout_to_list"><a href="#val-layout_to_list" class="anchor"></a><code><span class="keyword">val</span> layout_to_list : <a href="index.html#type-layout">layout</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int list</span></code></dt><dd><p>Convert a layout to a list for easier printing. Example: the layout with physical to logical qubit mapping {0-&gt;3, 1-&gt;4, 2-&gt;1, 3-&gt;2, 4-&gt;0} is transformed to the list <code>[3; 4; 1; 2; 0]</code>.</p></dd></dl></section></section></div></body></html>